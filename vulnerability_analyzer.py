"""
Vulnerability analyzer module for processing and analyzing security scan results.
"""

import logging
from typing import Dict, List, Any
from datetime import datetime, timedelta
from config import RISK_LEVELS

logger = logging.getLogger(__name__)

class SimpleVulnerabilityAnalyzer:
    def __init__(self):
        """Initialize the vulnerability analyzer."""
        self.risk_levels = RISK_LEVELS
        self.historical_data = []
        
    def analyze_vulnerabilities(self, scan_results: Dict[str, Any]) -> Dict[str, Any]:
        """
        Analyze vulnerabilities from scan results.
        
        Args:
            scan_results: Dictionary containing scan results
            
        Returns:
            Dictionary containing analysis results
        """
        try:
            # Handle case when scan_results is a list (direct alerts)
            if isinstance(scan_results, list):
                alerts = scan_results
            else:
                if "error" in scan_results:
                    return scan_results
                    
                alerts = scan_results.get("alerts", [])
                
            if not alerts:
                return {
                    "status": "success",
                    "message": "No vulnerabilities found",
                    "summary": {
                        "total": 0,
                        "by_risk": {},
                        "by_category": {}
                    }
                }
            
            # Initialize counters
            risk_counts = {level: 0 for level in self.risk_levels.keys()}
            category_counts = {}
            
            # Process each alert
            for alert in alerts:
                risk = alert.get("risk", "Info")
                category = alert.get("category", "Unknown")
                
                # Update risk counts
                if risk in risk_counts:
                    risk_counts[risk] += 1
                else:
                    risk_counts["Info"] += 1
                    
                # Update category counts
                if category in category_counts:
                    category_counts[category] += 1
                else:
                    category_counts[category] = 1
            
            # Calculate total score
            total_score = sum(
                count * self.risk_levels[risk]["score"]
                for risk, count in risk_counts.items()
            )
            
            # Store historical data
            self.historical_data.append({
                "timestamp": datetime.now().isoformat(),
                "total_vulnerabilities": len(alerts),
                "risk_counts": risk_counts,
                "total_score": total_score
            })
            
            # Keep only last 30 days of data
            cutoff_date = datetime.now() - timedelta(days=30)
            self.historical_data = [
                data for data in self.historical_data
                if datetime.fromisoformat(data["timestamp"]) > cutoff_date
            ]
            
            return {
                "status": "success",
                "summary": {
                    "total": len(alerts),
                    "by_risk": risk_counts,
                    "by_category": category_counts,
                    "total_score": total_score
                },
                "alerts": alerts,
                "trends": self._calculate_trends(),
                "recommendations": self._generate_recommendations(risk_counts)
            }
            
        except Exception as e:
            logger.error(f"Error analyzing vulnerabilities: {e}", exc_info=True)
            return {
                "status": "error",
                "message": "Failed to analyze vulnerabilities",
                "details": str(e)
            }
    
    def _calculate_trends(self) -> Dict[str, Any]:
        """Calculate vulnerability trends from historical data."""
        if not self.historical_data:
            return {
                "status": "no_data",
                "message": "No historical data available"
            }
            
        try:
            # Sort data by timestamp
            sorted_data = sorted(
                self.historical_data,
                key=lambda x: x["timestamp"]
            )
            
            # Calculate daily averages
            daily_averages = {}
            for data in sorted_data:
                date = datetime.fromisoformat(data["timestamp"]).date()
                if date not in daily_averages:
                    daily_averages[date] = {
                        "count": 0,
                        "total": 0
                    }
                daily_averages[date]["count"] += 1
                daily_averages[date]["total"] += data["total_vulnerabilities"]
            
            # Calculate trend
            trend_data = []
            for date, stats in daily_averages.items():
                trend_data.append({
                    "date": date.isoformat(),
                    "average_vulnerabilities": stats["total"] / stats["count"]
                })
            
            return {
                "status": "success",
                "data": trend_data
            }
            
        except Exception as e:
            logger.error(f"Error calculating trends: {e}", exc_info=True)
            return {
                "status": "error",
                "message": "Failed to calculate trends",
                "details": str(e)
            }
    
    def _generate_recommendations(self, risk_counts: Dict[str, int]) -> List[str]:
        """Generate recommendations based on vulnerability counts."""
        recommendations = []
        
        # High risk recommendations
        if risk_counts.get("High", 0) > 0:
            recommendations.append(
                "Critical: Address high-risk vulnerabilities immediately to prevent potential security breaches"
            )
            
        # Medium risk recommendations
        if risk_counts.get("Medium", 0) > 0:
            recommendations.append(
                "Important: Plan to address medium-risk vulnerabilities within the next week"
            )
            
        # Low risk recommendations
        if risk_counts.get("Low", 0) > 0:
            recommendations.append(
                "Note: Monitor and address low-risk vulnerabilities as part of regular maintenance"
            )
            
        # General recommendations
        total_vulnerabilities = sum(risk_counts.values())
        if total_vulnerabilities > 0:
            recommendations.append(
                f"Consider implementing additional security controls to reduce the total number of vulnerabilities ({total_vulnerabilities})"
            )
            
        return recommendations 